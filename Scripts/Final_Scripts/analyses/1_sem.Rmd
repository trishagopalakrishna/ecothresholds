```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE, include=FALSE}
library(RColorBrewer)
library(lattice)
library(tidyverse)
library(here)

library(ggplot2)
library(ggpubr)
library(sf)
library(terra)

library(tmap)
library(viridis)

terraOptions(memfrac=0.8, tempdir = here("Scratch"), progress=10)
```

##Introduction
In this script, I do structural equation modeling to understand causal relationships between 
environmental drives and abrupt shift count 

##Data input
```{r}
ndvi_agg_count <- rast (here("Outputs", "TrendsResults", "aggregate_trajectory_results", "monthly_ndvi_agg_count_5km.tif"))
#1-browning, 2-greening, 3- no trend

#static drivers
anthropic_dist<- rast(here("Outputs", "OtherVariables", "AnthropicDist", "5km_meandist_20thresholdsanthropicpixel.tif"))
hand<- rast(here("Outputs", "OtherVariables","HAND", "cerrado_hand_5km.tif"))

#trend variables
trend_burnedarea<- rast(here("Outputs", "OtherVariables", "Fire", "theilsen_burnedarea_5km.tif"))
trend_re<- rast(here("Outputs", "OtherVariables", "Climate", "theilsen_re.tif"))
trend_at<- rast(here("Outputs", "OtherVariables", "Climate", "theilsen_at_5km.tif"))
trend_spei<-rast(here("Outputs", "OtherVariables", "Climate", "theilsen_spei.tif"))
trend_heatwave<- rast(here("Outputs", "OtherVariables", "Climate", "theilsen_heatwaves.tif"))

#mean %area of veg formation
mean_savannapercentage <- rast(here("Outputs", "OtherVariables", "Formations_Heterogeniety", "mean_savanna_percentage_5km_2002_2021.tif"))

```

1) anthropic_dist - distance of the particular 5x5km grid cell to the closest anthropogenic land use
2) hand - water table depth, so value is the water table depth in meters

3) burnedarea - trend in the proportion of the 5x5km grid cell that burned through time
trend is calculated as the slope of a theilsen regression of annual burned area ~ time (21 years).
This theilsen regression has been applied to other "temporal" predictor variables explained below.
Basically the value in this column of the df is the slope from theilsen regression.
4) re- this is relative entropy which is a metric of seasonality. So positive slope values
means that actual rainfall in the 5x5km grid cell is becoming different from a equal amount of rainfall through the year 
(like uniform distribution across 12 months) faster and negative values is the same meaning but slower
4) mat - trend in annual temp. Similar interpretation- postive values mean that 
that 5x5km grid cell is getting hotter 
5) spei- this variable is also a trend where negative values mean that overall there are more droughts and
positive values mean that there are less droughts
6) heatwave- positive values means annual number of heatwaves is increasing 
7) savannapercentage- area of savanna vegetation in the 5x5 km grid cell that is increasing (positive values)
Above variables has not unit because its all slope. All trend varibales were calculated between 2002 and 2021.


##Preprocessing of all data- making appropriate data structure ie makign a dataframe (df) from 
geospatial data format
```{r}
#decrease <- ndvi_count_5km[[1]] +ndvi_count_5km[[4]] + ndvi_count_5km[[6]] + ndvi_count_5km[[7]]
#increase <- ndvi_count_5km[[2]] +ndvi_count_5km[[5]] + ndvi_count_5km[[8]] +ndvi_count_5km[[9]]

all_data <- c(ndvi_agg_count[[1]],ndvi_agg_count[[2]], anthropic_dist, trend_burnedarea, hand, trend_re, trend_at, trend_heatwave, trend_spei, mean_savannapercentage)
names(all_data)<- c("greening", "browning", "anthropic_dist", "trend_burnedarea", "hand", "trend_re", "trend_at", "trend_heatwave", "trend_spei", "mean_savannapercentage")

df1 <- terra::as.data.frame(all_data, na.rm= T)

remove(anthropic_dist, trend_burnedarea, hand, trend_re, trend_at, trend_heatwave, trend_spei, mean_savannapercentage)
remove(ndvi_agg_count)
```

#Exploratory data analyses
First because the sample size is the population, I know that all test statistics will
be unreliable, especially statistics like chi sq that are dependent on sample size. 
Hence I sample a % of the total data to run the SEM. I also plot the 
data to check if the different variables follow a Guassian distribution. 

I also scale the dataframe because all the units and magnitudes of variables int he df are 
very different.
```{r}
summary(df1)
green_df_noNA <- df1 %>% dplyr::select(-c(browning))
brown_df_noNA <- df1 %>% dplyr::select(-c(greening))

### Sampling 30% of the data resulting in 6306 rows of data
set.seed(1000)
sample_green_df <- green_df_noNA %>% slice_sample(prop=0.3, replace =F)
sample_brown_df <- brown_df_noNA  %>% slice_sample(prop=0.3, replace= F) #30% randomly sampled of entire dataset

#library(PerformanceAnalytics)
#chart.Correlation(sample_df, histogram = TRUE, pch= 19)

#Removing outliers considering distribution of height above nearest drainage variable
no_outliers_sample_green_df <- sample_green_df %>% 
  mutate (IQR = IQR(hand),
          O_upper = quantile (hand, probs= c(0.75), na.rm= FALSE)+ 1.5*IQR,
          O_lower = quantile(hand, probs= c(0.25), na.rm= FALSE) - 1.5*IQR
  ) %>% 
  filter(O_lower <= hand & hand <= O_upper) %>%
  dplyr::select(-c(IQR, O_upper, O_lower))

no_outliers_sample_brown_df <- sample_brown_df %>% 
  mutate (IQR = IQR(hand),
          O_upper = quantile (hand, probs= c(0.75), na.rm= FALSE)+ 1.5*IQR,
          O_lower = quantile(hand, probs= c(0.25), na.rm= FALSE) - 1.5*IQR
  ) %>% 
  filter(O_lower <= hand & hand <= O_upper) %>%
  dplyr::select(-c(IQR, O_upper, O_lower))


### Scaling data by centering around means due as the units and values of all variables are very different
scaled_analyses_green<- data.frame(scale(no_outliers_sample_green_df, center= TRUE, scale= TRUE)) 
scaled_analyses_brown<- data.frame(scale(no_outliers_sample_brown_df, center= TRUE, scale= TRUE)) 

#plot of distributions of scaled data
pivot_df_green <- scaled_analyses_green  %>%
  pivot_longer(1:9)
green_distribution_plot <- ggplot(data = pivot_df_green, aes(value)) +
  geom_histogram() +facet_wrap(~name, scales = "free", labeller = label_wrap_gen(4)) +
  theme_classic(base_size = 16)

pivot_df_brown <- scaled_analyses_brown  %>%
  pivot_longer(1:9)
brown_distribution_plot <- ggplot(data = pivot_df_brown, aes(value)) +
  geom_histogram() +facet_wrap(~name, scales = "free", labeller = label_wrap_gen(4)) +
  theme_classic(base_size = 16)
```
Response variables of "stable" area is right skewed (because most of the Brazilian savanna biome is stable).
Most of the drivers/predictors are normally distributed.

#Analyses - 1 considering composite SEM using partial least square path modelling using cSEM in R

```{r}
#install.packages("cSEM")
library(lavaan)
library(cSEM)

######## Greening model
greening <- '
  STEPINC ~ BACKGROUND_CLIMATE + PULSE_STRESSORS + WATER_ACCESS + VEGETATION + ANTHROPIC_PRESSURES + FIRE
  VEGETATION ~ PULSE_STRESSORS + BACKGROUND_CLIMATE +ANTHROPIC_PRESSURES + FIRE + WATER_ACCESS
  FIRE ~ PULSE_STRESSORS + BACKGROUND_CLIMATE + ANTHROPIC_PRESSURES
  WATER_ACCESS ~ ANTHROPIC_PRESSURES
  PULSE_STRESSORS ~ ANTHROPIC_PRESSURES
  BACKGROUND_CLIMATE ~ ANTHROPIC_PRESSURES
  
  BACKGROUND_CLIMATE <~ trend_re + trend_at
  PULSE_STRESSORS <~ trend_heatwave + trend_spei
  
  STEPINC =~ greening
  WATER_ACCESS =~ hand
  VEGETATION =~ mean_savannapercentage
  FIRE =~ trend_burnedarea
  ANTHROPIC_PRESSURES =~ anthropic_dist
'
Sys.time(); greening_model1 <- cSEM::csem(.data = no_outliers_sample_green_df,
                                         .model = greening,
                                         .approach_weights = "PLS-PM",
                                         .resample_method = "bootstrap",
                                         .R =1000,
                                         .seed = 1000); Sys.time()


cSEM::summarize(greening_model1)
x_greening_assess <- cSEM::assess(greening_model1)
cSEM::verify(greening_model1)
green_modelfit <- cSEM::testOMF(greening_model1)

######## Browning model
browning <- '
  STEPDEC ~ BACKGROUND_CLIMATE + PULSE_STRESSORS + WATER_ACCESS + VEGETATION + ANTHROPIC_PRESSURES + FIRE
  VEGETATION ~ PULSE_STRESSORS + BACKGROUND_CLIMATE +ANTHROPIC_PRESSURES + FIRE + WATER_ACCESS
  FIRE ~ PULSE_STRESSORS + BACKGROUND_CLIMATE + ANTHROPIC_PRESSURES
  WATER_ACCESS ~ ANTHROPIC_PRESSURES
  PULSE_STRESSORS ~ ANTHROPIC_PRESSURES
  BACKGROUND_CLIMATE ~ ANTHROPIC_PRESSURES
  
  BACKGROUND_CLIMATE <~ trend_re + trend_at
  PULSE_STRESSORS <~ trend_heatwave + trend_spei
  
  STEPDEC =~ browning
  WATER_ACCESS =~ hand
  VEGETATION =~ mean_savannapercentage
  FIRE =~ trend_burnedarea
  ANTHROPIC_PRESSURES =~ anthropic_dist
'
Sys.time(); browning_model1 <- cSEM::csem(.data = no_outliers_sample_brown_df,
                                         .model = browning,
                                         .approach_weights = "PLS-PM",
                                         .resample_method = "bootstrap",
                                         .R =1000,
                                         .seed = 1000); Sys.time()

cSEM::summarize(browning_model1)
x_browning_assess <- cSEM::assess(browning_model1)
cSEM::verify(browning_model1)
brown_modelfit <- cSEM::testOMF(browning_model1)

 #model fit statistics look good - R2 for structural regression equations from "assess()" results for reporting
 # model admissibility looks good
 #reject null hypothesis, so model fit to observed data is poor! Need to clarify

```

Verification of model fit ie the acceptable range of values of various model fit statistics can be taken from
https://www.smartpls.com/documentation/functionalities/thresholds
which includes the thresholds used by SmartPLS software.

#Analyses - 2- using H-O specification
Based on Yu et al 2025- A flexible way to study composites in ecology using structural equation modeling, I decided
to use the H-O specification to overcome the problems of 2 step (above chunk and generally used for composited) and 1 step
SEM. As per Schuberth's email, cSEM freely estimates the weights of the composites using partial least square path modelling. 
So implementing H-O with free weights option.
```{r}
library(lavaan)

modelho_f1<-'

# Specify emergent variables and label their loadings.
Background_Climate =~ NA*re + l11*mat + l12*re
l11 + l12 == 1

Pulse_Shocks =~ NA*heatwave + l13*spei + l14*heatwave
l13 + l14 == 1

# Label the variances of emergent variables.
Background_Climate ~~ vbackgroundclimate*Background_Climate
Pulse_Shocks ~~ vpulseshocks*Pulse_Shocks

# Specify the excrescent variables and label their loadings.
nu1 =~ re + 122*mat
nu2 =~ heatwave + 131*spei

# Label the variances of excrescent variables.
nu1 ~~ vnu1*nu1
nu2 ~~ vnu2*nu2

# Specify common factors.
Instability =~ NDVI_instability
NDVI_instability ~~ 1*NDVI_instability

Fire =~ burnedarea
burnedarea ~~ 1*burnedarea

AnthropicPressure =~ anthropic_dist
anthropic_dist ~~ 1*anthropic_dist

SavannaPhy =~ savannapercentage
savannapercentage ~~ 1*savannapercentage

WaterTable =~ hand
hand ~~ 1*hand

# Constrain the covariances of the excrescent variables
# with other variables in the structural model to zero.
# Label the covariances among excrescent variables within blocks.
nu1 ~~ 0*Background_Climate + 0*Pulse_Shocks + 0*Instability + 0*Fire + 0*AnthropicPressure + 0*SavannaPhy + 0*WaterTable + 0*nu2
nu2 ~~ 0*Background_Climate + 0*Pulse_Shocks + 0*Instability + 0*Fire + 0*AnthropicPressure + 0*SavannaPhy + 0*WaterTable

# Fix the variances of the measurement errors to zero.
re ~~ 0*re
mat ~~ 0*mat
heatwave ~~ 0*heatwave
spei ~~ 0*spei

# Specify the structural model.
Instability ~ Background_Climate + Pulse_Shocks + WaterTable + SavannaPhy + AnthropicPressure + Fire
SavannaPhy  ~ Pulse_Shocks  + Background_Climate + AnthropicPressure + Fire
Fire ~ Pulse_Shocks + Background_Climate + AnthropicPressure
WaterTable ~ AnthropicPressure

# Specify weights
wre := 1 / (l11 + l12)
wmat := 1 / (l11 + l12)

wheatwave := 1 / (l13 + l14)
wdrought := 1 / (l13 + l14)

vre := ((l12)*(l12)*(vbackgroundclimate)) + ((1)*(1)*(vnu1))
vmat := ((l11)*(l11)*(vbackgroundclimate)) + ((1)*(1)*(vnu1))

vheatwave := (l14)*(l14)*(vpulseshocks) + (-1)*(-1)*(vnu2)
vdrought := (l13)*(l13)*(vpulseshocks) + (1)*(1)*(vnu2)

wres := wre * sqrt(vre / vbackgroundclimate)
wmats := wmat * sqrt(vmat / vbackgroundclimate)

wheatwaves := wheatwave * sqrt(vheatwave / vpulseshocks)
wdroughts := wdrought * sqrt(vdrought / vpulseshocks)
'

Sys.time(); outho_f1=sem(model = modelho_f1, data = scaled_analyses_ndviinstability); Sys.time()
summary(outho_f1, standardized=T, fit.measures=T)  
standardizedsolution(outho_f1)

```
